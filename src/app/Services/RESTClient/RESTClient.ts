//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v6.11.6129.25106 (NJsonSchema v4.28.6128.27588) (http://NSwag.org)
// </auto-generated>
//----------------------

import 'rxjs/Rx'; 
import {Observable} from 'rxjs/Observable';
import {Injectable, Inject, Optional, OpaqueToken} from '@angular/core';
import {Http, Headers, Response, RequestOptionsArgs} from '@angular/http';

export const API_BASE_URL = new OpaqueToken('API_BASE_URL');

export interface ILoginClient {
    /**
     * Verifico che il sistema sia online
     */
    online(): Observable<CheckOnlineStatusModel>;
    /**
     * login
     */
    login(utente: Utente): Observable<CheckOnlineStatusModel>;
}

@Injectable()
export class LoginClient implements ILoginClient {
    private http: Http = null; 
    private baseUrl: string = undefined; 

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http; 
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * Verifico che il sistema sia online
     */
    online(): Observable<CheckOnlineStatusModel> {
        let url_ = this.baseUrl + "/api/online"; 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processOnline(response);
        });
    }

    private processOnline(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: CheckOnlineStatusModel = null; 
            let resultData200 = data === "" ? null : JSON.parse(data);
            result200 = resultData200 ? CheckOnlineStatusModel.fromJS(resultData200) : null;
            return result200; 
        }
        else
        {
            throw "error_no_callback_for_the_received_http_status"; 
        }
    }

    /**
     * login
     */
    login(utente: Utente): Observable<CheckOnlineStatusModel> {
        let url_ = this.baseUrl + "/api/login"; 

        const content_ = JSON.stringify(utente ? utente.toJS() : null);
        
        return this.http.request(url_, {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processLogin(response);
        });
    }

    private processLogin(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: CheckOnlineStatusModel = null; 
            let resultData200 = data === "" ? null : JSON.parse(data);
            result200 = resultData200 ? CheckOnlineStatusModel.fromJS(resultData200) : null;
            return result200; 
        }
        else
        {
            throw "error_no_callback_for_the_received_http_status"; 
        }
    }
}

export interface IDevicesClient {
    /**
     * Lista dei Devices trovati
     */
    getDevices(): Observable<AltaiBTDevice[]>;
}

@Injectable()
export class DevicesClient implements IDevicesClient {
    private http: Http = null; 
    private baseUrl: string = undefined; 

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http; 
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * Lista dei Devices trovati
     */
    getDevices(): Observable<AltaiBTDevice[]> {
        let url_ = this.baseUrl + "/api/getdevices"; 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processGetDevices(response);
        });
    }

    private processGetDevices(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: AltaiBTDevice[] = null; 
            let resultData200 = data === "" ? null : JSON.parse(data);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(AltaiBTDevice.fromJS(item));
            }
            return result200; 
        }
        else
        {
            throw "error_no_callback_for_the_received_http_status"; 
        }
    }
}

export interface IDomoticaImpiantoClient {
    /**
     * Impianto salvato
     */
    getImpianto(): Observable<Impianto>;
    /**
     * Impianto salvato
     */
    salvaImpianto(imp: Impianto): Observable<void>;
}

@Injectable()
export class DomoticaImpiantoClient implements IDomoticaImpiantoClient {
    private http: Http = null; 
    private baseUrl: string = undefined; 

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http; 
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * Impianto salvato
     */
    getImpianto(): Observable<Impianto> {
        let url_ = this.baseUrl + "/api/getimpianto"; 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "get",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processGetImpianto(response);
        });
    }

    private processGetImpianto(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: Impianto = null; 
            let resultData200 = data === "" ? null : JSON.parse(data);
            result200 = resultData200 ? Impianto.fromJS(resultData200) : null;
            return result200; 
        }
        else
        {
            throw "error_no_callback_for_the_received_http_status"; 
        }
    }

    /**
     * Impianto salvato
     */
    salvaImpianto(imp: Impianto): Observable<void> {
        let url_ = this.baseUrl + "/api/salvaimpianto"; 

        const content_ = JSON.stringify(imp ? imp.toJS() : null);
        
        return this.http.request(url_, {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processSalvaImpianto(response);
        });
    }

    private processSalvaImpianto(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "204") {
        }
        else
        {
            throw "error_no_callback_for_the_received_http_status"; 
        }
    }
}

export interface IDomoticaClient {
    /**
     * Connetti sistema di domotica
     */
    connettiSistemaDomotica(): Observable<boolean>;
    openserial(): Observable<boolean>;
}

@Injectable()
export class DomoticaClient implements IDomoticaClient {
    private http: Http = null; 
    private baseUrl: string = undefined; 

    constructor(@Inject(Http) http: Http, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http; 
        this.baseUrl = baseUrl ? baseUrl : ""; 
    }

    /**
     * Connetti sistema di domotica
     */
    connettiSistemaDomotica(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/connettisistemadomotica"; 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processConnettiSistemaDomotica(response);
        });
    }

    private processConnettiSistemaDomotica(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: boolean = null; 
            let resultData200 = data === "" ? null : JSON.parse(data);
            result200 = resultData200 !== undefined ? resultData200 : null;
            return result200; 
        }
        else
        {
            throw "error_no_callback_for_the_received_http_status"; 
        }
    }

    openserial(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/Domotica/openserial"; 

        const content_ = "";
        
        return this.http.request(url_, {
            body: content_,
            method: "post",
            headers: new Headers({
                "Content-Type": "application/json; charset=UTF-8"
            })
        }).map((response) => {
            return this.processOpenserial(response);
        });
    }

    private processOpenserial(response: Response) {
        const data = response.text();
        const status = response.status.toString(); 

        if (status === "200") {
            let result200: boolean = null; 
            let resultData200 = data === "" ? null : JSON.parse(data);
            result200 = resultData200 !== undefined ? resultData200 : null;
            return result200; 
        }
        else
        {
            throw "error_no_callback_for_the_received_http_status"; 
        }
    }
}

export class ADomoticaModel { 
    stato: HttpStatusCodeAsInteger; 
    messaggio: string; 
    stackTrace: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.stato = data["Stato"] !== undefined ? data["Stato"] : null;
            this.messaggio = data["Messaggio"] !== undefined ? data["Messaggio"] : null;
            this.stackTrace = data["StackTrace"] !== undefined ? data["StackTrace"] : null;
        }
    }

    static fromJS(data: any): ADomoticaModel {
        return new ADomoticaModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["Stato"] = this.stato !== undefined ? this.stato : null;
        data["Messaggio"] = this.messaggio !== undefined ? this.messaggio : null;
        data["StackTrace"] = this.stackTrace !== undefined ? this.stackTrace : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new ADomoticaModel(JSON.parse(json));
    }
}

export class CheckOnlineStatusModel extends ADomoticaModel {

    constructor(data?: any) {
        super(data);
        if (data !== undefined) {
        }
    }

    static fromJS(data: any): CheckOnlineStatusModel {
        return new CheckOnlineStatusModel(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        super.toJS(data);
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new CheckOnlineStatusModel(JSON.parse(json));
    }
}

export enum HttpStatusCodeAsInteger {
    Continue = 100, 
    SwitchingProtocols = 101, 
    OK = 200, 
    Created = 201, 
    Accepted = 202, 
    NonAuthoritativeInformation = 203, 
    NoContent = 204, 
    ResetContent = 205, 
    PartialContent = 206, 
    MultipleChoices = 300, 
    Ambiguous = 300, 
    MovedPermanently = 301, 
    Moved = 301, 
    Found = 302, 
    Redirect = 302, 
    SeeOther = 303, 
    RedirectMethod = 303, 
    NotModified = 304, 
    UseProxy = 305, 
    Unused = 306, 
    TemporaryRedirect = 307, 
    RedirectKeepVerb = 307, 
    BadRequest = 400, 
    Unauthorized = 401, 
    PaymentRequired = 402, 
    Forbidden = 403, 
    NotFound = 404, 
    MethodNotAllowed = 405, 
    NotAcceptable = 406, 
    ProxyAuthenticationRequired = 407, 
    RequestTimeout = 408, 
    Conflict = 409, 
    Gone = 410, 
    LengthRequired = 411, 
    PreconditionFailed = 412, 
    RequestEntityTooLarge = 413, 
    RequestUriTooLong = 414, 
    UnsupportedMediaType = 415, 
    RequestedRangeNotSatisfiable = 416, 
    ExpectationFailed = 417, 
    UpgradeRequired = 426, 
    InternalServerError = 500, 
    NotImplemented = 501, 
    BadGateway = 502, 
    ServiceUnavailable = 503, 
    GatewayTimeout = 504, 
    HttpVersionNotSupported = 505, 
}

export class Utente { 
    username: string; 
    password: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.username = data["username"] !== undefined ? data["username"] : null;
            this.password = data["password"] !== undefined ? data["password"] : null;
        }
    }

    static fromJS(data: any): Utente {
        return new Utente(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["username"] = this.username !== undefined ? this.username : null;
        data["password"] = this.password !== undefined ? this.password : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Utente(JSON.parse(json));
    }
}

export class AltaiBTDevice { 
    address: string; 
    authenticated: boolean; 
    connected: boolean; 
    deviceName: string; 
    riconosciutoCome: string; 
    selected: boolean;

    constructor(data?: any) {
        if (data !== undefined) {
            this.address = data["address"] !== undefined ? data["address"] : null;
            this.authenticated = data["authenticated"] !== undefined ? data["authenticated"] : null;
            this.connected = data["connected"] !== undefined ? data["connected"] : null;
            this.deviceName = data["deviceName"] !== undefined ? data["deviceName"] : null;
            this.riconosciutoCome = data["riconosciutoCome"] !== undefined ? data["riconosciutoCome"] : null;
            this.selected = data["selected"] !== undefined ? data["selected"] : null;
        }
    }

    static fromJS(data: any): AltaiBTDevice {
        return new AltaiBTDevice(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["address"] = this.address !== undefined ? this.address : null;
        data["authenticated"] = this.authenticated !== undefined ? this.authenticated : null;
        data["connected"] = this.connected !== undefined ? this.connected : null;
        data["deviceName"] = this.deviceName !== undefined ? this.deviceName : null;
        data["riconosciutoCome"] = this.riconosciutoCome !== undefined ? this.riconosciutoCome : null;
        data["selected"] = this.selected !== undefined ? this.selected : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new AltaiBTDevice(JSON.parse(json));
    }
}

export class Impianto { 
    domoticaId: string; 
    nome: string; 
    piani: Piano[]; 
    gruppi: Gruppo[]; 
    devices: DeviceDomotica[];

    constructor(data?: any) {
        if (data !== undefined) {
            this.domoticaId = data["domoticaId"] !== undefined ? data["domoticaId"] : null;
            this.nome = data["nome"] !== undefined ? data["nome"] : null;
            if (data["piani"] && data["piani"].constructor === Array) {
                this.piani = [];
                for (let item of data["piani"])
                    this.piani.push(Piano.fromJS(item));
            }
            if (data["gruppi"] && data["gruppi"].constructor === Array) {
                this.gruppi = [];
                for (let item of data["gruppi"])
                    this.gruppi.push(Gruppo.fromJS(item));
            }
            if (data["devices"] && data["devices"].constructor === Array) {
                this.devices = [];
                for (let item of data["devices"])
                    this.devices.push(DeviceDomotica.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Impianto {
        return new Impianto(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["domoticaId"] = this.domoticaId !== undefined ? this.domoticaId : null;
        data["nome"] = this.nome !== undefined ? this.nome : null;
        if (this.piani && this.piani.constructor === Array) {
            data["piani"] = [];
            for (let item of this.piani)
                data["piani"].push(item.toJS());
        }
        if (this.gruppi && this.gruppi.constructor === Array) {
            data["gruppi"] = [];
            for (let item of this.gruppi)
                data["gruppi"].push(item.toJS());
        }
        if (this.devices && this.devices.constructor === Array) {
            data["devices"] = [];
            for (let item of this.devices)
                data["devices"].push(item.toJS());
        }
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Impianto(JSON.parse(json));
    }
}

export class Piano { 
    domoticaId: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.domoticaId = data["domoticaId"] !== undefined ? data["domoticaId"] : null;
        }
    }

    static fromJS(data: any): Piano {
        return new Piano(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["domoticaId"] = this.domoticaId !== undefined ? this.domoticaId : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Piano(JSON.parse(json));
    }
}

export class Gruppo { 
    domoticaId: string;

    constructor(data?: any) {
        if (data !== undefined) {
            this.domoticaId = data["domoticaId"] !== undefined ? data["domoticaId"] : null;
        }
    }

    static fromJS(data: any): Gruppo {
        return new Gruppo(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["domoticaId"] = this.domoticaId !== undefined ? this.domoticaId : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new Gruppo(JSON.parse(json));
    }
}

export class DeviceDomotica { 
    domoticaId: string; 
    nome: string; 
    tipo: number; 
    position: DisplayPosition; 
    image: string; 
    imageOn: string; 
    imageOff: string; 
    valore: number;

    constructor(data?: any) {
        if (data !== undefined) {
            this.domoticaId = data["domoticaId"] !== undefined ? data["domoticaId"] : null;
            this.nome = data["nome"] !== undefined ? data["nome"] : null;
            this.tipo = data["tipo"] !== undefined ? data["tipo"] : null;
            this.position = data["position"] ? DisplayPosition.fromJS(data["position"]) : null;
            this.image = data["image"] !== undefined ? data["image"] : null;
            this.imageOn = data["imageOn"] !== undefined ? data["imageOn"] : null;
            this.imageOff = data["imageOff"] !== undefined ? data["imageOff"] : null;
            this.valore = data["valore"] !== undefined ? data["valore"] : null;
        }
    }

    static fromJS(data: any): DeviceDomotica {
        return new DeviceDomotica(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["domoticaId"] = this.domoticaId !== undefined ? this.domoticaId : null;
        data["nome"] = this.nome !== undefined ? this.nome : null;
        data["tipo"] = this.tipo !== undefined ? this.tipo : null;
        data["position"] = this.position ? this.position.toJS() : null;
        data["image"] = this.image !== undefined ? this.image : null;
        data["imageOn"] = this.imageOn !== undefined ? this.imageOn : null;
        data["imageOff"] = this.imageOff !== undefined ? this.imageOff : null;
        data["valore"] = this.valore !== undefined ? this.valore : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new DeviceDomotica(JSON.parse(json));
    }
}

export class DisplayPosition { 
    x: number; 
    y: number; 
    z: number;

    constructor(data?: any) {
        if (data !== undefined) {
            this.x = data["x"] !== undefined ? data["x"] : null;
            this.y = data["y"] !== undefined ? data["y"] : null;
            this.z = data["z"] !== undefined ? data["z"] : null;
        }
    }

    static fromJS(data: any): DisplayPosition {
        return new DisplayPosition(data);
    }

    toJS(data?: any) {
        data = data === undefined ? {} : data;
        data["x"] = this.x !== undefined ? this.x : null;
        data["y"] = this.y !== undefined ? this.y : null;
        data["z"] = this.z !== undefined ? this.z : null;
        return data; 
    }

    toJSON() {
        return JSON.stringify(this.toJS());
    }

    clone() {
        var json = this.toJSON();
        return new DisplayPosition(JSON.parse(json));
    }
}